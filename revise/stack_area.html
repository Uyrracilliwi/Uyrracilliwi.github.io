<!DOCTYPE html>

<script src="https://d3js.org/d3.v4.js"></script>
<div id="my_dataviz"></div>
<div id="chart">
    <div id="explanation" style="visibility: hidden;">
      <span id="percentage"></span><br/>
      of visits begin with this sequence of pages
    </div>
</div>
<fieldset>
    <legend>Graph Options</legend>

    <h3 class=first-h3>Number of Bubbles to show</h3>
    <div><select id=limit></select></div>

    <h3>Total Electricity Usage/Percentage Electricity Usage</h3>
    <select id="shuffle">
        <option value="0">Largest to smallest</option>
        <option value="1">Sunburst</option>
    </select>
    
    <h3>Background Color</h3>  
    <select id=bg>
      <option value="#e0e0e0">Gray</option>
      <option value="#eeeeee">Gray 2</option>
      <option value="#111111">Dark</option>
    </select>
</fieldset>

<script>
    // 修改背景颜色
    const bgSelect = document.querySelector('#bg');
    bgSelect.addEventListener('change', render);

    // 载入gdp vs population
    const shuffleSelect = document.querySelector('#shuffle');
    shuffleSelect.addEventListener('change', render);

    render();
    

    function render(){
        const bgColor = bgSelect.options[bgSelect.selectedIndex].value;
        document.body.style.backgroundColor = bgColor;

        if (shuffleSelect.selectedIndex === 1){
            d3.select("svg").remove()
            // sunburst
            // Dimensions of sunburst.
            var width = 750;
            var height = 600;
            var radius = Math.min(width, height) / 2;

            // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
            var b = {
                w: 75, h: 30, s: 3, t: 10
            };

            // Mapping of step names to colors.
            
            /*
            var colors = {
                "industrial": "#5687d1",
                "commercial": "#7b615c",
                "residential": "#de783b",
                "direct": "#6ab975",
                "all other uses": "#a173d1",
                "space cooling" : '#ffff33'
            };
            */
            var colors = d3.scaleOrdinal(d3.schemeCategory20c)
            

            // Total size of all segments; we set this later, after loading the data.
            var totalSize = 0; 

            var vis = d3.select("#chart").append("svg:svg")
                .attr("width", width)
                .attr("height", height)
                .append("svg:g")
                .attr("id", "container")
                .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

            var partition = d3.partition()
                .size([2 * Math.PI, radius * radius])
                

            var arc = d3.arc()
                .startAngle(function(d) { return d.x0; })
                .endAngle(function(d) { return d.x1; })
                .innerRadius(function(d) { return Math.sqrt(d.y0); })
                .outerRadius(function(d) { return Math.sqrt(d.y1); });


            // modification is here
            d3.json("flare.json",function(error, root){
                if (error) throw error;
                createVisualization(root)
            })

            function createVisualization(json) {

                // Basic setup of page elements.
                initializeBreadcrumbTrail();
                drawLegend();
                d3.select("#togglelegend").on("click", toggleLegend);

                // Bounding circle underneath the sunburst, to make it easier to detect
                // when the mouse leaves the parent g.
                vis.append("svg:circle")
                    .attr("r", radius)
                    .style("opacity", 0);

                // Turn the data into a d3 hierarchy and calculate the sums.
                var root = d3.hierarchy(json)
                    .sum(function(d) { return d.size; })
                    .sort(function(a, b) { return b.value - a.value; });

                // For efficiency, filter nodes to keep only those large enough to see.
                var nodes = partition(root).descendants()
                    .filter(function(d) {
                        return (d.x1 - d.x0 > 0.005); // 0.005 radians = 0.29 degrees
                    });

                var path = vis.data([json]).selectAll("path")
                    .data(nodes)
                    .enter().append("svg:path")
                    .attr("display", function(d) { return d.depth ? null : "none"; })
                    .attr("d", arc)
                    .attr("fill-rule", "evenodd")
                    .style("fill", function(d) { return colors((d.children ? d.data : d.parent).name); })
                    .style("opacity", 1)
                    .on("mouseover", mouseover);

                // Add the mouseleave handler to the bounding circle.
                d3.select("#container").on("mouseleave", mouseleave);

                // Get total size of the tree = value of root node from partition.
                totalSize = path.datum().value;
            };
            // Fade all but the current sequence, and show it in the breadcrumb trail.

            function mouseover(d) {

                var percentage = (100 * d.value / totalSize).toPrecision(3);
                var percentageString = percentage + "%";
                if (percentage < 0.1) {
                percentageString = "< 0.1%";
                }

                d3.select("#percentage")
                    .text(percentageString);

                d3.select("#explanation")
                    .style("visibility", "");

                var sequenceArray = d.ancestors().reverse();
                sequenceArray.shift(); // remove root node from the array
                updateBreadcrumbs(sequenceArray, percentageString);

                // Fade all the segments.
                d3.selectAll("path")
                    .style("opacity", 0.3);

                // Then highlight only those that are an ancestor of the current segment.
                vis.selectAll("path")
                    .filter(function(node) {
                            return (sequenceArray.indexOf(node) >= 0);
                            })
                    .style("opacity", 1);
            }

            // Restore everything to full opacity when moving off the visualization.
            function mouseleave(d) {

                // Hide the breadcrumb trail
                d3.select("#trail")
                    .style("visibility", "hidden");

                // Deactivate all segments during transition.
                d3.selectAll("path").on("mouseover", null);

                // Transition each segment to full opacity and then reactivate it.
                d3.selectAll("path")
                    .transition()
                    .duration(1000)
                    .style("opacity", 1)
                    .on("end", function() {
                            d3.select(this).on("mouseover", mouseover);
                        });

                d3.select("#explanation")
                    .style("visibility", "hidden");
                }

                function initializeBreadcrumbTrail() {
                // Add the svg area.
                var trail = d3.select("#sequence").append("svg:svg")
                    .attr("width", width)
                    .attr("height", 50)
                    .attr("id", "trail");
                // Add the label at the end, for the percentage.
                trail.append("svg:text")
                .attr("id", "endlabel")
                .style("fill", "#000");
                }

                // Generate a string that describes the points of a breadcrumb polygon.
                function breadcrumbPoints(d, i) {
                var points = [];
                points.push("0,0");
                points.push(b.w + ",0");
                points.push(b.w + b.t + "," + (b.h / 2));
                points.push(b.w + "," + b.h);
                points.push("0," + b.h);
                if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
                points.push(b.t + "," + (b.h / 2));
                }
                return points.join(" ");
                }

                // Update the breadcrumb trail to show the current sequence and percentage.
                function updateBreadcrumbs(nodeArray, percentageString) {

                // Data join; key function combines name and depth (= position in sequence).
                var trail = d3.select("#trail")
                    .selectAll("g")
                    .data(nodeArray, function(d) { return d.data.name + d.depth; });

                // Remove exiting nodes.
                trail.exit().remove();

                // Add breadcrumb and label for entering nodes.
                var entering = trail.enter().append("svg:g");

                entering.append("svg:polygon")
                    .attr("points", breadcrumbPoints)
                    .style("fill", function(d) { return colors((d.children ? d.data : d.parent).name)});

                entering.append("svg:text")
                    .attr("x", (b.w + b.t) / 2)
                    .attr("y", b.h / 2)
                    .attr("dy", "0.35em")
                    .attr("text-anchor", "middle")
                    .text(function(d) { return d.data.name; });

                // Merge enter and update selections; set position for all nodes.
                entering.merge(trail).attr("transform", function(d, i) {
                return "translate(" + i * (b.w + b.s) + ", 0)";
                });

                // Now move and update the percentage at the end.
                d3.select("#trail").select("#endlabel")
                    .attr("x", (nodeArray.length + 0.5) * (b.w + b.s))
                    .attr("y", b.h / 2)
                    .attr("dy", "0.35em")
                    .attr("text-anchor", "middle")
                    .text(percentageString);

                // Make the breadcrumb trail visible, if it's hidden.
                d3.select("#trail")
                    .style("visibility", "");

            }

            function drawLegend() {

                // Dimensions of legend item: width, height, spacing, radius of rounded rect.
                var li = {
                w: 75, h: 30, s: 3, r: 3
                };

                var legend = d3.select("#legend").append("svg:svg")
                    .attr("width", li.w)
                    .attr("height", d3.keys(colors).length * (li.h + li.s));

                var g = legend.selectAll("g")
                    .data(d3.entries(colors))
                    .enter().append("svg:g")
                    .attr("transform", function(d, i) {
                            return "translate(0," + i * (li.h + li.s) + ")";
                        });

                g.append("svg:rect")
                    .attr("rx", li.r)
                    .attr("ry", li.r)
                    .attr("width", li.w)
                    .attr("height", li.h)
                    .style("fill", function(d) { return d.value; });

                g.append("svg:text")
                    .attr("x", li.w / 2)
                    .attr("y", li.h / 2)
                    .attr("dy", "0.35em")
                    .attr("text-anchor", "middle")
                    .text(function(d) { return d.key; });
            }

            function toggleLegend() {
                var legend = d3.select("#legend");
                if (legend.style("visibility") == "hidden") {
                legend.style("visibility", "");
                } else {
                legend.style("visibility", "hidden");
                }
            }   


        }else{
            d3.select("svg").remove()
            var margin = {top: 20, right: 30, bottom: 30, left: 55},
            width = 1060 - margin.left - margin.right,
            height = 780 - margin.top - margin.bottom;
            // set the dimensions and margins of the graph
            // append the svg object to the body of the page
            var svg = d3.select("#my_dataviz")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");
            
            // Parse the Data
            d3.csv("retail-major-sectors - retail-major-sectors.csv", function(data) {
        
            // List of groups = header of the csv files
            var keys = data.columns.slice(1)
        
            // Add X axis
            var x = d3.scaleLinear()
            .domain(d3.extent(data, function(d) { return d.year; }))
            .range([ 0, width ]);
            svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x).ticks(5));
        
            // Add Y axis
            var y = d3.scaleLinear()
            .domain([0, 4.5])
            .range([ height, 0 ]);
            svg.append("g")
            .call(d3.axisLeft(y));
        
            // color palette
            var color = d3.scaleOrdinal()
            .domain(keys)
            .range(['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'])
        
            //stack the data
            var stackedData = d3.stack()
            .keys(keys)
            (data)
        
            // Show the areas
            svg
            .selectAll("mylayers")
            .data(stackedData)
            .enter()
            .append("path")
                .style("fill", function(d) { console.log(d.key) ; return color(d.key); })
                .attr("d", d3.area()
                .x(function(d, i) { return x(d.data.year); })
                .y0(function(d) { return y(d[0]); })
                .y1(function(d) { return y(d[1]); })
            )
        })
        }
    }
</script>
  

